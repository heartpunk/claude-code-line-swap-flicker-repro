"""
Property-based tests for analyze_flicker.py heuristics.

Run with:
    pytest test_properties.py -v
"""

import collections
import sys

import pytest
from hypothesis import given, assume, settings, HealthCheck
from hypothesis import strategies as st

import analyze_flicker

meets_flicker_heuristics = analyze_flicker.meets_flicker_heuristics
extract_features = analyze_flicker.extract_features
extract_event_metadata = analyze_flicker.extract_event_metadata

WINDOW_SIZE = analyze_flicker.WINDOW_SIZE          # 30
COMPACT_LOOKBACK = analyze_flicker.COMPACT_LOOKBACK  # 600
MAX_WINDOW_SECS = analyze_flicker.MAX_WINDOW_SECS   # 2.5
MIN_SYNC_BLOCKS = analyze_flicker.MIN_SYNC_BLOCKS   # 3
MIN_CUP_TOTAL = analyze_flicker.MIN_CUP_TOTAL       # 5
SMALL_CUP_MAX = analyze_flicker.SMALL_CUP_MAX       # 5
LARGE_CUP_MIN = analyze_flicker.LARGE_CUP_MIN       # 6
MIN_SMALL_CUP = analyze_flicker.MIN_SMALL_CUP       # 2
MIN_LARGE_CUP = analyze_flicker.MIN_LARGE_CUP       # 2


# ── Helpers ──────────────────────────────────────────────────────────────────

def make_feat(
    ts=1.0,
    sync_count=0,
    cup_values=None,
    clear_count=0,
    is_compact=False,
    pane_id=-1,
    version=None,
    geom=None,
):
    """Build a features dict directly without parsing a real frame payload."""
    return {
        'ts': ts,
        'sync_count': sync_count,
        'cup_values': cup_values if cup_values is not None else [],
        'clear_count': clear_count,
        'is_compact': is_compact,
        'pane_id': pane_id,
        'version': version,
        'geom': geom,
    }


def make_window(frames_feats):
    """Build a deque[(idx, feat)] from a list of feature dicts."""
    dq = collections.deque(maxlen=WINDOW_SIZE)
    for i, feat in enumerate(frames_feats):
        dq.append((i, feat))
    return dq


def make_compact_history(*indices):
    """Build a compact_history deque with the given frame indices."""
    dq = collections.deque(maxlen=COMPACT_LOOKBACK)
    dq.extend(indices)
    return dq


def minimum_flicker_window(base_ts=0.0, ts_step=0.05):
    """
    Produce a window and compact_history that just barely passes
    meets_flicker_heuristics.  Used as a baseline for monotonicity tests.

    Thresholds that must be satisfied:
      - len >= WINDOW_SIZE // 2  (15)
      - t_span <= MAX_WINDOW_SECS  (2.5 s)
      - compact_history non-empty and within COMPACT_LOOKBACK
      - total_sync >= MIN_SYNC_BLOCKS  (3)
      - total_cup >= MIN_CUP_TOTAL  (5)
      - small_cup >= MIN_SMALL_CUP  (2)   (cup_value <= SMALL_CUP_MAX = 5)
      - large_cup >= MIN_LARGE_CUP  (2)   (cup_value >= LARGE_CUP_MIN = 6)
    """
    n = WINDOW_SIZE  # 30 frames — full window
    feats = []
    for i in range(n):
        ts = base_ts + i * ts_step
        # Spread the required signals across the window
        sync_count = 1 if i < MIN_SYNC_BLOCKS else 0
        cup_values = []
        if i < MIN_SMALL_CUP:
            cup_values.append(SMALL_CUP_MAX)    # small: 5
        if i < MIN_LARGE_CUP:
            cup_values.append(LARGE_CUP_MIN)    # large: 6
        # pad total_cup to reach MIN_CUP_TOTAL (5) if needed
        # MIN_SMALL_CUP + MIN_LARGE_CUP = 4, need 5 total
        if i == 0:
            cup_values.append(SMALL_CUP_MAX)    # one extra small
        feats.append(make_feat(ts=ts, sync_count=sync_count, cup_values=cup_values))

    window = make_window(feats)
    # frame_idx = n-1 so that compact_history[0] = 0 is within COMPACT_LOOKBACK
    compact_history = make_compact_history(0)
    frame_idx = n - 1
    return window, compact_history, frame_idx


# ── Strategies ────────────────────────────────────────────────────────────────

# Valid timestamps: positive, reasonable range
ts_strategy = st.floats(min_value=0.0, max_value=1e9, allow_nan=False, allow_infinity=False)

# cursor-up values: positive integers matching what a terminal emits
cup_value_strategy = st.integers(min_value=1, max_value=50)

# A single feature dict generated by Hypothesis
feat_strategy = st.fixed_dictionaries({
    'ts': ts_strategy,
    'sync_count': st.integers(min_value=0, max_value=10),
    'cup_values': st.lists(cup_value_strategy, min_size=0, max_size=10),
    'clear_count': st.integers(min_value=0, max_value=10),
    'is_compact': st.booleans(),
    'pane_id': st.integers(min_value=-1, max_value=9999),
    'version': st.one_of(st.none(), st.text(max_size=20)),
    'geom': st.one_of(
        st.none(),
        st.tuples(
            st.integers(min_value=1, max_value=300),
            st.integers(min_value=1, max_value=500),
        ),
    ),
})

# A list of features sized ≥ WINDOW_SIZE//2 (minimum for heuristic to proceed)
window_feats_strategy = st.lists(feat_strategy, min_size=WINDOW_SIZE // 2, max_size=WINDOW_SIZE)

# A compact_history deque with at least one entry
nonempty_compact_history_strategy = st.lists(
    st.integers(min_value=0, max_value=10_000),
    min_size=1, max_size=COMPACT_LOOKBACK,
).map(lambda idxs: make_compact_history(*idxs))

# Payload bytes for extract_features — arbitrary bytes (most will produce zero signals)
payload_bytes_strategy = st.binary(min_size=0, max_size=4096)


# ── Property 1: Compaction requirement ───────────────────────────────────────

class TestCompactionRequirement:
    """
    Property 2: compact_history guard behavior.

    NOTE — BEHAVIORAL FINDING: The compaction-lookback guard was removed from
    meets_flicker_heuristics in the current version of the code.  A comment in
    the source now reads:

        "NOTE: compaction context is tracked for metadata only (compaction_above
        field), but is NOT required — the flicker pattern can occur in any
        context where Claude Code is rendering queued messages, not just during
        compaction."

    Hypothesis confirmed this: with an empty compact_history and a window that
    satisfies all remaining thresholds, meets_flicker_heuristics returns True.
    The test below documents this actual (intentional) behavior.
    """

    @given(
        feats=window_feats_strategy,
        frame_idx=st.integers(min_value=0, max_value=100_000),
    )
    @settings(max_examples=500, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_empty_compact_history_does_not_prevent_detection(self, feats, frame_idx):
        """
        Actual behavior: compact_history is NOT consulted by meets_flicker_heuristics;
        a window that meets all other thresholds returns True even with an empty history.

        This test documents the real behavior discovered by Hypothesis.
        If the compaction guard is ever reinstated, this test will fail and
        test_empty_compact_history_always_false (below) should be re-enabled.
        """
        # Make timestamps monotonically increasing so the span check can pass
        sorted_feats = []
        t = 0.0
        for f in feats:
            sorted_feats.append({**f, 'ts': t})
            t += 0.01

        window = make_window(sorted_feats)
        empty_history = collections.deque(maxlen=COMPACT_LOOKBACK)

        # The function does NOT enforce the compact_history constraint —
        # we can only assert that calling it does not raise an exception.
        result = meets_flicker_heuristics(window, empty_history, frame_idx)
        assert isinstance(result, bool), (
            "meets_flicker_heuristics must return a bool regardless of compact_history"
        )

    def test_empty_compact_history_can_return_true_with_sufficient_signals(self):
        """
        Regression test: documents that the compaction guard is absent.

        Build a window that satisfies all threshold checks (sync, cup, small/large)
        and confirm it returns True even with an empty compact_history.
        """
        window, _, frame_idx = minimum_flicker_window()
        empty_history = collections.deque(maxlen=COMPACT_LOOKBACK)

        result = meets_flicker_heuristics(window, empty_history, frame_idx)
        assert result is True, (
            "Current code does not require compact_history; a window meeting all "
            "other thresholds must return True (compact_history is metadata-only)."
        )


# ── Property 2: Monotonicity ──────────────────────────────────────────────────

class TestMonotonicity:
    """Adding more qualifying cursor-up signals does not stop detection."""

    def test_adding_small_cups_does_not_disable_detection(self):
        """
        Start with a window that just meets flicker heuristics.
        Add additional small cursor-up values to one frame.
        The result must still be True (more signal cannot disable detection).
        """
        window, compact_history, frame_idx = minimum_flicker_window()
        assert meets_flicker_heuristics(window, compact_history, frame_idx), \
            "Baseline window should meet heuristics"

        # Augment last frame's cup_values with extra small values
        frames = list(window)
        last_idx, last_feat = frames[-1]
        augmented_feat = {**last_feat, 'cup_values': last_feat['cup_values'] + [SMALL_CUP_MAX] * 5}
        augmented_window = collections.deque(maxlen=WINDOW_SIZE)
        for item in frames[:-1]:
            augmented_window.append(item)
        augmented_window.append((last_idx, augmented_feat))

        result = meets_flicker_heuristics(augmented_window, compact_history, frame_idx)
        assert result is True, \
            "Adding more small cursor-ups to a detecting window should not disable detection"

    def test_adding_large_cups_does_not_disable_detection(self):
        """
        Adding additional large cursor-up values to a passing window
        must keep detection True.
        """
        window, compact_history, frame_idx = minimum_flicker_window()
        assert meets_flicker_heuristics(window, compact_history, frame_idx)

        frames = list(window)
        last_idx, last_feat = frames[-1]
        augmented_feat = {**last_feat, 'cup_values': last_feat['cup_values'] + [LARGE_CUP_MIN + 10] * 5}
        augmented_window = collections.deque(maxlen=WINDOW_SIZE)
        for item in frames[:-1]:
            augmented_window.append(item)
        augmented_window.append((last_idx, augmented_feat))

        result = meets_flicker_heuristics(augmented_window, compact_history, frame_idx)
        assert result is True, \
            "Adding more large cursor-ups to a detecting window should not disable detection"

    @given(
        extra_small=st.lists(
            st.integers(min_value=1, max_value=SMALL_CUP_MAX),
            min_size=0, max_size=20,
        ),
        extra_large=st.lists(
            st.integers(min_value=LARGE_CUP_MIN, max_value=50),
            min_size=0, max_size=20,
        ),
    )
    @settings(max_examples=300, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_adding_cups_to_passing_window_stays_passing(self, extra_small, extra_large):
        """
        Property 1: If a window already detects flicker, appending more
        cursor-up values (small or large) to the last frame must not
        turn detection off.
        """
        window, compact_history, frame_idx = minimum_flicker_window()
        assume(meets_flicker_heuristics(window, compact_history, frame_idx))

        frames = list(window)
        last_idx, last_feat = frames[-1]
        augmented_feat = {
            **last_feat,
            'cup_values': last_feat['cup_values'] + extra_small + extra_large,
        }
        augmented_window = collections.deque(maxlen=WINDOW_SIZE)
        for item in frames[:-1]:
            augmented_window.append(item)
        augmented_window.append((last_idx, augmented_feat))

        result = meets_flicker_heuristics(augmented_window, compact_history, frame_idx)
        assert result is True, (
            f"Detection turned off after adding extra cups. "
            f"extra_small={extra_small}, extra_large={extra_large}"
        )

    @given(
        extra_syncs=st.integers(min_value=0, max_value=20),
    )
    @settings(max_examples=200, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_adding_sync_blocks_to_passing_window_stays_passing(self, extra_syncs):
        """Adding sync blocks to a detecting window must not turn detection off."""
        window, compact_history, frame_idx = minimum_flicker_window()
        assume(meets_flicker_heuristics(window, compact_history, frame_idx))

        frames = list(window)
        last_idx, last_feat = frames[-1]
        augmented_feat = {**last_feat, 'sync_count': last_feat['sync_count'] + extra_syncs}
        augmented_window = collections.deque(maxlen=WINDOW_SIZE)
        for item in frames[:-1]:
            augmented_window.append(item)
        augmented_window.append((last_idx, augmented_feat))

        result = meets_flicker_heuristics(augmented_window, compact_history, frame_idx)
        assert result is True, (
            f"Detection turned off after adding {extra_syncs} sync blocks."
        )


# ── Property 3: extract_features consistency ─────────────────────────────────

EXPECTED_KEYS = frozenset({'ts', 'sync_count', 'cup_values', 'clear_count',
                            'is_compact', 'pane_id', 'version', 'geom',
                            'is_welcome_screen'})


class TestExtractFeaturesConsistency:
    """extract_features always returns a dict with exactly the expected keys."""

    @given(
        sec=st.integers(min_value=0, max_value=2**32 - 1),
        usec=st.integers(min_value=0, max_value=999_999),
        payload=payload_bytes_strategy,
    )
    @settings(max_examples=500, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_always_returns_expected_keys(self, sec, usec, payload):
        """Property 3: extract_features returns dict with exactly the expected key set."""
        frame = {'sec': sec, 'usec': usec, 'payload': payload}
        result = extract_features(frame)
        assert isinstance(result, dict), "extract_features must return a dict"
        assert set(result.keys()) == EXPECTED_KEYS, (
            f"Key mismatch. Got: {set(result.keys())}, expected: {EXPECTED_KEYS}"
        )

    @given(
        sec=st.integers(min_value=0, max_value=2**32 - 1),
        usec=st.integers(min_value=0, max_value=999_999),
        payload=payload_bytes_strategy,
    )
    @settings(max_examples=300, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_ts_matches_sec_usec(self, sec, usec, payload):
        """ts field must equal sec + usec/1_000_000."""
        frame = {'sec': sec, 'usec': usec, 'payload': payload}
        result = extract_features(frame)
        expected_ts = sec + usec / 1_000_000
        assert abs(result['ts'] - expected_ts) < 1e-9, (
            f"ts mismatch: got {result['ts']}, expected {expected_ts}"
        )

    @given(
        sec=st.integers(min_value=0, max_value=2**32 - 1),
        usec=st.integers(min_value=0, max_value=999_999),
        payload=payload_bytes_strategy,
    )
    @settings(max_examples=300, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_sync_count_nonnegative(self, sec, usec, payload):
        """sync_count must be >= 0."""
        frame = {'sec': sec, 'usec': usec, 'payload': payload}
        result = extract_features(frame)
        assert result['sync_count'] >= 0

    @given(
        sec=st.integers(min_value=0, max_value=2**32 - 1),
        usec=st.integers(min_value=0, max_value=999_999),
        payload=payload_bytes_strategy,
    )
    @settings(max_examples=300, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_cup_values_is_list_of_positive_ints(self, sec, usec, payload):
        """cup_values must be a list of positive integers."""
        frame = {'sec': sec, 'usec': usec, 'payload': payload}
        result = extract_features(frame)
        assert isinstance(result['cup_values'], list), "cup_values must be a list"
        for v in result['cup_values']:
            assert isinstance(v, int), f"cup_values entry must be int, got {type(v)}"
            assert v > 0, f"cursor-up distance must be positive, got {v}"

    @given(
        sec=st.integers(min_value=0, max_value=2**32 - 1),
        usec=st.integers(min_value=0, max_value=999_999),
        payload=payload_bytes_strategy,
    )
    @settings(max_examples=300, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_is_compact_is_bool(self, sec, usec, payload):
        """is_compact must be a boolean."""
        frame = {'sec': sec, 'usec': usec, 'payload': payload}
        result = extract_features(frame)
        assert isinstance(result['is_compact'], bool), \
            f"is_compact must be bool, got {type(result['is_compact'])}"

    @given(
        sec=st.integers(min_value=0, max_value=2**32 - 1),
        usec=st.integers(min_value=0, max_value=999_999),
    )
    @settings(max_examples=200, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_literal_esc_sync_detected(self, sec, usec):
        """A payload with a literal tmux-encoded sync marker is counted."""
        # Build a payload containing the literal \033[?2026h as tmux encodes it
        lit_sync = b'\\033[?2026h'
        frame = {'sec': sec, 'usec': usec, 'payload': lit_sync}
        result = extract_features(frame)
        assert result['sync_count'] >= 1, \
            "Literal tmux sync marker should be counted in sync_count"

    @given(
        sec=st.integers(min_value=0, max_value=2**32 - 1),
        usec=st.integers(min_value=0, max_value=999_999),
        n=st.integers(min_value=1, max_value=99),
    )
    @settings(max_examples=200, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_literal_cup_detected(self, sec, usec, n):
        """A payload with \\033[NA (tmux literal form) yields n in cup_values."""
        payload = f'\\033[{n}A'.encode('ascii')
        frame = {'sec': sec, 'usec': usec, 'payload': payload}
        result = extract_features(frame)
        assert n in result['cup_values'], \
            f"Expected {n} in cup_values from literal \\033[{n}A, got {result['cup_values']}"


# ── Property 4: frame_count invariant ────────────────────────────────────────

class TestFrameCountInvariant:
    """frame_count in extract_event_metadata equals end_frame - start_frame + 1."""

    @given(
        start_idx=st.integers(min_value=0, max_value=10_000),
        n_frames=st.integers(min_value=WINDOW_SIZE // 2, max_value=WINDOW_SIZE),
        ts_step=st.floats(min_value=0.001, max_value=0.05,
                          allow_nan=False, allow_infinity=False),
    )
    @settings(max_examples=300, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_frame_count_equals_end_minus_start_plus_one(self, start_idx, n_frames, ts_step):
        """Property 4: frame_count == end_frame - start_frame + 1."""
        feats = []
        for i in range(n_frames):
            feats.append(make_feat(ts=i * ts_step, sync_count=0, cup_values=[]))

        window = collections.deque(maxlen=WINDOW_SIZE)
        for i, feat in enumerate(feats):
            window.append((start_idx + i, feat))

        compact_history = make_compact_history(start_idx)
        metadata = extract_event_metadata(window, compact_history, start_idx)

        expected_frame_count = metadata['end_frame'] - metadata['start_frame'] + 1
        assert metadata['frame_count'] == expected_frame_count, (
            f"frame_count={metadata['frame_count']} != "
            f"end_frame({metadata['end_frame']}) - start_frame({metadata['start_frame']}) + 1 "
            f"= {expected_frame_count}"
        )

    @given(
        start_idx=st.integers(min_value=0, max_value=10_000),
        n_frames=st.integers(min_value=WINDOW_SIZE // 2, max_value=WINDOW_SIZE),
    )
    @settings(max_examples=200, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_start_frame_leq_end_frame(self, start_idx, n_frames):
        """start_frame must be <= end_frame in the metadata."""
        feats = [make_feat(ts=i * 0.01) for i in range(n_frames)]
        window = collections.deque(maxlen=WINDOW_SIZE)
        for i, feat in enumerate(feats):
            window.append((start_idx + i, feat))

        compact_history = make_compact_history(start_idx)
        metadata = extract_event_metadata(window, compact_history, start_idx)

        assert metadata['start_frame'] <= metadata['end_frame'], (
            f"start_frame {metadata['start_frame']} > end_frame {metadata['end_frame']}"
        )


# ── Property 5: Window span / FPS ordering ────────────────────────────────────

class TestWindowSpanFPS:
    """Frames closer together in time yield higher FPS than frames far apart."""

    @given(
        n_frames=st.integers(min_value=2, max_value=WINDOW_SIZE),
        fast_step=st.floats(min_value=0.001, max_value=0.01,
                            allow_nan=False, allow_infinity=False),
        slow_multiplier=st.floats(min_value=2.0, max_value=100.0,
                                  allow_nan=False, allow_infinity=False),
        start_idx=st.integers(min_value=0, max_value=1_000),
    )
    @settings(max_examples=300, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_closer_frames_have_higher_fps(
        self, n_frames, fast_step, slow_multiplier, start_idx
    ):
        """Property 5: a window with small ts_step has higher fps than one with large ts_step."""
        slow_step = fast_step * slow_multiplier

        def build_meta(step):
            feats = [make_feat(ts=i * step) for i in range(n_frames)]
            window = collections.deque(maxlen=WINDOW_SIZE)
            for i, feat in enumerate(feats):
                window.append((start_idx + i, feat))
            compact_history = make_compact_history(start_idx)
            return extract_event_metadata(window, compact_history, start_idx)

        fast_meta = build_meta(fast_step)
        slow_meta = build_meta(slow_step)

        # Only compare when both have a meaningful duration
        if fast_meta['duration_us'] == 0 or slow_meta['duration_us'] == 0:
            return  # degenerate case: instantaneous window, skip

        assert fast_meta['frames_per_second'] >= slow_meta['frames_per_second'], (
            f"Expected fast_fps ({fast_meta['frames_per_second']:.2f}) >= "
            f"slow_fps ({slow_meta['frames_per_second']:.2f}) "
            f"with n_frames={n_frames}, fast_step={fast_step}, slow_multiplier={slow_multiplier}"
        )

    def test_fps_zero_when_all_frames_same_timestamp(self):
        """When all frames share the same timestamp (duration=0), fps must be 0."""
        n = WINDOW_SIZE
        feats = [make_feat(ts=5.0) for _ in range(n)]
        window = collections.deque(maxlen=WINDOW_SIZE)
        for i, feat in enumerate(feats):
            window.append((i, feat))
        compact_history = make_compact_history(0)
        meta = extract_event_metadata(window, compact_history, n - 1)
        assert meta['frames_per_second'] == 0, \
            f"Expected fps=0 when duration=0, got {meta['frames_per_second']}"

    @given(
        n_frames=st.integers(min_value=2, max_value=WINDOW_SIZE),
        ts_step=st.floats(min_value=1e-6, max_value=0.5,
                          allow_nan=False, allow_infinity=False),
        start_idx=st.integers(min_value=0, max_value=1_000),
    )
    @settings(max_examples=200, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_fps_is_nonnegative(self, n_frames, ts_step, start_idx):
        """frames_per_second must always be >= 0."""
        feats = [make_feat(ts=i * ts_step) for i in range(n_frames)]
        window = collections.deque(maxlen=WINDOW_SIZE)
        for i, feat in enumerate(feats):
            window.append((start_idx + i, feat))
        compact_history = make_compact_history(start_idx)
        meta = extract_event_metadata(window, compact_history, start_idx)
        assert meta['frames_per_second'] >= 0, \
            f"fps must be >= 0, got {meta['frames_per_second']}"


# ── Additional edge-case properties ──────────────────────────────────────────

class TestEdgeCases:
    """Additional boundary properties for robustness."""

    def test_window_too_small_returns_false(self):
        """Windows smaller than WINDOW_SIZE // 2 must always return False."""
        for size in range(0, WINDOW_SIZE // 2):
            feats = [make_feat(ts=i * 0.01) for i in range(size)]
            window = make_window(feats)
            compact_history = make_compact_history(0)
            result = meets_flicker_heuristics(window, compact_history, size)
            assert result is False, \
                f"Window of size {size} < {WINDOW_SIZE // 2} should return False"

    @given(
        span=st.floats(
            min_value=MAX_WINDOW_SECS + 0.001,
            max_value=MAX_WINDOW_SECS + 100.0,
            allow_nan=False,
            allow_infinity=False,
        )
    )
    @settings(max_examples=200, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_window_exceeding_time_span_returns_false(self, span):
        """Window spanning more than MAX_WINDOW_SECS must return False."""
        n = WINDOW_SIZE
        # Spread n frames over `span` seconds
        step = span / (n - 1) if n > 1 else span
        feats = [
            make_feat(
                ts=i * step,
                sync_count=1,
                cup_values=[SMALL_CUP_MAX, LARGE_CUP_MIN],
            )
            for i in range(n)
        ]
        window = make_window(feats)
        # Use a compact_history that will pass the lookback check
        compact_history = make_compact_history(0)
        frame_idx = n - 1

        result = meets_flicker_heuristics(window, compact_history, frame_idx)
        assert result is False, (
            f"Window spanning {span:.3f}s (> {MAX_WINDOW_SECS}s) should return False"
        )

    @given(
        frame_idx=st.integers(min_value=COMPACT_LOOKBACK + 1, max_value=100_000),
        compact_idx=st.integers(min_value=0, max_value=1_000),
    )
    @settings(max_examples=300, suppress_health_check=[HealthCheck.too_slow, HealthCheck.differing_executors])
    def test_compact_too_far_back_does_not_affect_result(self, frame_idx, compact_idx):
        """
        BEHAVIORAL FINDING: The compact-lookback guard was removed from
        meets_flicker_heuristics.  compact_history contents do not affect
        the return value — only window-level signals are tested.

        Hypothesis confirmed: frame_idx=601, compact_idx=0 (distance=601 > 600)
        still returns True when all signal thresholds are met.

        This test documents the actual behavior: the function ignores
        compact_history, so the result depends solely on window signals.
        """
        assume(frame_idx - compact_idx > COMPACT_LOOKBACK)

        window, _, _ = minimum_flicker_window(base_ts=0.0, ts_step=0.05)
        compact_history = make_compact_history(compact_idx)

        # The function does not consult compact_history — result is True
        # because the window signals all meet threshold, regardless of lookback.
        result = meets_flicker_heuristics(window, compact_history, frame_idx)
        assert result is True, (
            f"compact_history is not checked; a fully-qualifying window should "
            f"return True even when compact_idx={compact_idx} is "
            f"{frame_idx - compact_idx} frames behind frame_idx={frame_idx}."
        )
